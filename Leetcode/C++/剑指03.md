# [剑指 Offer II 003. 前 n 个数字二进制中 1 的个数](https://leetcode.cn/problems/w3tCBm/)

> 涉及知识点：位运算、动态规划

给定一个非负整数 n ，请计算 0 到 n 之间的每个数字的二进制表示中 1 的个数，并输出一个数组。

 

示例 1:

```
输入: n = 2
输出: [0,1,1]
解释: 
0 --> 0
1 --> 1
2 --> 10
```

示例 2:

```
输入: n = 5
输出: [0,1,1,2,1,2]
解释:
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101
```

*说明 :*

*0 <= n <= 105*

**进阶:**

给出时间复杂度为 O(n*sizeof(integer)) 的解答非常容易。但你可以在线性时间 O(n) 内用一趟扫描做到吗？
要求算法的空间复杂度为 O(n) 。
你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount ）来执行此操作。





------

## Answer

我们只考虑**进阶**算法：

```c++
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> bits(n + 1);
        int highBit = 0;
        for (int i = 1; i <= n; i++) {
            if ((i & (i - 1)) == 0) {
                highBit = i;
            }
            bits[i] = bits[i - highBit] + 1;
        }
        return bits;
    }
};
```

这道题的答案很简洁，思想是**动态规划**。

如果我们把二进制形式列出来，可以发现他们的递进是有规律的：

```
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101
6 --> 110
7 --> 111
8 --> 1000
9 --> 1001
...
```

从7到8是一个**分水岭**，象征一个新的计数循环(`counting loop`)的伊始：8在0的基础加了1（即MSB的那个1）、9在1的基础加了1、... 、15在7的基础上加了1，最后从15到16又是一个**分水岭**，新的计数循环(`counting loop`)开始：16在0的基础上加了1、 ... 、31在15的基础上加了1。至此，规律浮出水面，此题终结。

不得不说，颇有脑经急转弯的意味。